<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stats of match</title>
    <link rel="stylesheet" href="css/base.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        :root { --bg:#0b0f14; --panel:#121822; --muted:#99a3ad; --text:#e6edf3; --accent:#5cc8ff; }
        body{background:var(--bg);color:var(--text);margin:0;padding-top:70px;font-family:sans-serif}
        header{padding:20px;text-align:center;background:#121822; position:fixed; top:0; width:100%; z-index:100;}
        .home-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text);
            text-decoration: none;
            padding: 8px 16px;
            border: 1px solid var(--muted);
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s;
        }
        .home-button:hover {
            background-color: var(--muted);
            color: var(--bg);
        }
        .dados{padding:20px}
        h1,h2{margin:6px 0}
        .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px;padding:20px}
        .card{grid-column:span 12;background:var(--panel);border-radius:12px;padding:12px}
        .card h2{margin:0 0 8px;font-size:16px}
        .card svg{width:100%;height:auto;display:block}
        .card.small{grid-column:span 6}
        .card.third{grid-column:span 4}
        /* Nova classe para ocupar 2/3 da largura */
        .card.two-thirds {
            grid-column: span 8;
        }
        .placeholder-text { text-align: center; color: var(--muted); padding: 20px; }
        @media(max-width:900px){.card.small,.card.third, .card.two-thirds{grid-column:span 12}}
        .tooltip{position:fixed;pointer-events:none;background:#0e1622;color:#e6edf3;border:1px solid #1e2633;border-radius:10px;padding:8px 10px;font-size:12px;opacity:0;transform:translate(-50%,-120%);white-space:nowrap;z-index:10}
        .timeaz{color: #3b82f6;}
        .timever{color: #f97316;}
        table {width:100%;border-collapse:collapse;margin-top:10px;font-size: 14px;}
        th, td {padding:8px;text-align:left;border-bottom:1px solid #1e2633}
        .info-text { font-size: 14px; font-weight: normal; color: var(--muted); margin-left: 10px; }
        .win-chance-info {
            padding: 10px;
            border-top: 1px solid var(--muted);
            margin-top: 10px;
        }
        .over-zones {
            display: flex;
            width: 100%;
            margin-top: 0;
            border-radius: 8px;
            overflow: hidden;
        }
        .over-zone {
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            padding: 0 5px;
            text-align: center;
            white-space: nowrap;
        }
        .over-zone span {
            font-size: 0.60vw; /* Fonte responsiva */
            white-space: normal; /* Permite a quebra de linha */
            display: block;
        }
        .over-zone.red {
            background-color: #ef4444;
            width: 15%;
        }
        .over-zone.light-green {
            background-color: #84cc16;
            width: 15%;
        }
        .over-zone.green {
            background-color: #22c55e;
            width: 20%;
        }
        .over-zone.light-blue {
            background-color: #38bdf8;
            width: 15%;
        }
        .over-zone.blue {
            background-color: #2563eb;
            width: 15%;
        }
        .over-zone.dark-green {
            background-color: #16a34a;
            width: 20%;
        }
    </style>
</head>
<body>
    <header>
        <a href="./index.html" class="home-button">Home</a>
        <h1 class="rubik-700 texto" id="mainHeader">Carregando partida...</h1>
    </header>

    <div class="dados">
        <h1 class="rubik-500 texto">Dados da partida: </h1>
        <h2 class="rubik-500 texto" id="matchTitle">Jogo: <span>Carregando...</span></h2>
        <h2 class="rubik-500 texto" id="status">Status: <span>Carregando...</span></h2>
        <h2 class="rubik-500 texto" id="idJogo">ID: <span>Carregando...</span></h2>
        <h2 class="rubik-500 texto" id="teams">Times: <span>Carregando...</span></h2>
    </div>

    <main class="grid">
        <section class="card small" id="teamPerformance">
            <h2>Desempenho dos Times</h2>
            <div class="placeholder-text" id="teamPerformancePlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 320"></svg>
        </section>
        <section class="card small" id="overPerformance">
            <h2>Pontos por Over</h2>
            <div class="placeholder-text" id="overPerformancePlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 320"></svg>
            <div class="over-zones">
                <div class="over-zone red"><span>Não entrar Over 1-3</span></div>
                <div class="over-zone light-green"><span>Over 4-6 WICKET < 2</span></div>
                <div class="over-zone green"><span>Over 7-10 WICKET < 3</span></div>
                <div class="over-zone light-blue"><span>Over 11-13 WICKET < 4</span></div>
                <div class="over-zone blue"><span>Over 14-16 WICKET < 5</span></div>
                <div class="over-zone dark-green"><span>Over 17-20 WICKET < 6</span></div>
            </div>
            <div class="win-chance-info">
                <h3>Chance de Vitória</h3>
                <div id="winChancePlaceholder">Calculando...</div>
                <div id="winChanceInfo"></div>
            </div>
        </section>
        <section class="card" id="worm">
            <h2>Worm (Corrida Acumulada)</h2>
            <div class="placeholder-text" id="wormPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 320"></svg>
        </section>
        <section class="card" id="playersTables">
            <h2>Jogadores</h2>
            <div class="placeholder-text" id="playersTablesPlaceholder">Carregando dados dos jogadores...</div>

            <h3 id="battersHeader">Batters</h3>
            <table class="batter-table">
                <thead>
                    <tr>
                        <th>Nome</th>
                        <th>Runs</th>
                        <th>Bolas</th>
                        <th>4s</th>
                        <th>6s</th>
                        <th>SR</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>

            <h3 style="margin-top: 20px;">Bowlers</h3>
            <table class="bowler-table">
                <thead>
                    <tr>
                        <th>Nome</th>
                        <th>Overs</th>
                        <th>Runs</th>
                        <th>Wkts</th>
                        <th>Mdns</th>
                        <th>Dots</th>
                        <th>Wd</th>
                        <th>NB</th>
                        <th>Econ</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </section>
        <section class="card third" id="currentPlayers">
            <h2>Jogadores Atuais</h2>
            <div class="placeholder-text" id="currentPlayersPlaceholder">Carregando informações...</div>
            <div id="currentPlayersInfo"></div>
        </section>
        <section class="card two-thirds" id="manhattan">
            <h2>Manhattan (Runs por Over)</h2>
            <div class="placeholder-text" id="manhattanPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 320"></svg>
        </section>
        <section class="card third" id="fow">
            <h2>Queda de Wickets (FOW)</h2>
            <div class="placeholder-text" id="fowPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 320"></svg>
        </section>
        <section class="card third" id="batsmen">
            <h2>Batsmen</h2>
            <div class="placeholder-text" id="batsmenPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 420"></svg>
        </section>
        <section class="card third" id="bowlers">
            <h2>Bowlers</h2>
            <div class="placeholder-text" id="bowlersPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 420"></svg>
        </section>
        <section class="card third" id="recent">
            <h2>Overs Recentes</h2>
            <div class="placeholder-text" id="recentPlaceholder">Carregando gráfico...</div>
            <svg viewBox="0 0 900 240"></svg>
        </section>
    </main>

    <div class="tooltip" id="tip"></div>

</body>
<script>
const params = new Proxy(new URLSearchParams(window.location.search), {
    get: (searchParams, prop) => searchParams.get(prop),
});
let ID = params.id;
let controller;
let firstRender = true;
// ---------------- LÓGICA DE NORMALIZAÇÃO E ANÁLISE (DO PYTHON) ----------------
function walk(obj, result = []) {
    if (obj !== null && typeof obj === 'object') {
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                result.push([key, obj[key]]);
                if (typeof obj[key] === 'object' && obj[key] !== null) {
                    walk(obj[key], result);
                }
            }
        }
    }
    return result;
}
function _find_list_by_key(sr_json, key_lower) {
    let found = null;
    for (const [k, v] of walk(sr_json)) {
        if (typeof k === 'string' && k.toLowerCase() === key_lower && Array.isArray(v)) {
            found = v;
            break;
        }
    }
    return found;
}
function _merge_over_lists(lists) {
    const mapping = {};
    for (const lst of lists) {
        if (!Array.isArray(lst)) continue;
        for (const o of lst) {
            if (typeof o === 'object' && 'overNumber' in o) {
                const on = parseInt(o.overNumber || o.over || 0, 10) || 0;
                if (on <= 0) continue;
                const prev = mapping[on] || {};
                const merged = { ...prev };
                for (const k in o) {
                    if (o[k] !== null && o[k] !== '' && (Array.isArray(o[k]) ? o[k].length > 0 : true)) {
                        merged[k] = o[k];
                    }
                }
                mapping[on] = merged;
            }
        }
    }
    return Object.keys(mapping).sort((a,b) => a-b).map(k => mapping[k]);
}
function _find_bbs_merged(sr_json) {
    const lists = [];
    for (const key of ["ballbyballsummaries", "recentovers"]) {
        const lst = _find_list_by_key(sr_json, key);
        if (Array.isArray(lst)) lists.push(lst);
    }
    
    const scoreNode = _score_node(sr_json);
    for (const key of ["ballByBallSummaries", "recentOvers"]) {
        const lst = scoreNode[key];
        if (Array.isArray(lst)) lists.push(lst);
    }
    
    return _merge_over_lists(lists);
}
function _parse_ball_token(tok) {
    if (tok === null) return { runs: 0, wicket: false, boundary: false };
    const s = String(tok).trim().toLowerCase();
    if (s === "" || s === "." || s === "·" || s === "-" || s === "—" || s === "dot") return { runs: 0, wicket: false, boundary: false };
    if (s === "w") return { runs: 0, wicket: true, boundary: false };
    
    let m = s.match(/^wd\+?(\d+)?$/);
    if (m) return { runs: 1 + (parseInt(m[1], 10) || 0), wicket: false, boundary: false };
    
    m = s.match(/^nb\+?(\d+)?$/);
    if (m) {
        const batRuns = parseInt(m[1], 10) || 0;
        return { runs: 1 + batRuns, wicket: false, boundary: [4, 6].includes(batRuns) };
    }
    
    m = s.match(/^(\d+)\s*(lb|b)$/);
    if (m) return { runs: parseInt(m[1], 10), wicket: false, boundary: false };
    
    m = s.match(/^(\d+)$/);
    if (m) {
        const n = parseInt(m[1], 10);
        return { runs: n, wicket: false, boundary: [4, 6].includes(n) };
    }
    
    const nums = (s.match(/\d+/g) || []).map(Number);
    const boundary = !s.includes("lb") && !s.includes("b") && !s.includes("wd") && nums.some(n => n === 4 || n === 6);
    return { runs: nums.reduce((sum, n) => sum + n, 0), wicket: false, boundary: false };
}
function _overs_to_float(overs) {
    if (overs === null) return 0.0;
    try {
        const s = String(overs).trim();
        if (s.includes(".")) {
            const [a, b] = s.split(".", 2);
            return parseInt(a, 10) + (parseInt(b, 10) / 6.0);
        }
        return parseFloat(s);
    } catch (e) {
        return 0.0;
    }
}
function _looks_out(it) {
    const keys = ["isOut", "out", "dismissed", "didNotBat"];
    if (keys.some(k => it[k])) return true;
    const txt = ["status", "Status", "description", "desc", "howOut", "outDesc"].map(k => String(it[k] || "")).join(" ").toLowerCase();
    if (txt.includes("not out")) return false;
    return ["retired", "run out", "lbw", "bowled", "caught", " out"].some(w => txt.includes(w));
}
function _score_node(sr_json) {
    const cands = [];
    for (const [k, v] of walk(sr_json)) {
        if (v !== null && typeof v === 'object' && ("innings" in v || "Innings" in v)) {
            cands.push(v);
        }
        if (k === "score" && v !== null && typeof v === 'object') {
            cands.push(v);
        }
    }
    return cands[cands.length - 1] || {};
}
function _current_innings_node(score, bbs) {
    if (score === null || typeof score !== 'object') {
        return {};
    }
    const inns = score.innings || score.Innings || [];
    if (Array.isArray(inns)) {
        const current = inns.find(x => x.isCurrent === true || ["live", "inprogress", "in progress", "current", "ongoing"].some(s => String(x.status).toLowerCase().includes(s)));
        if (current) return current;
        if (bbs.some(o => o.secondInnings)) return inns[1] || (inns.length > 0 ? inns[inns.length - 1] : {});
        return inns.length > 0 ? inns[inns.length - 1] : {};
    }
    return {};
}
function _extract_batsmen_exact(inn) {
    const bats = [];
    for (const [k, v] of walk(inn)) {
        if (typeof k === 'string' && k.toLowerCase() === "batsmen" && Array.isArray(v)) {
            for (const it of v) {
                if (typeof it !== 'object' || it === null) continue;
                const nm = it.batsmanName || it.name;
                if (!nm) continue;
                bats.push({
                    name: nm,
                    on: it.onstrike || it.onStrike,
                    runs: parseInt(it.runs, 10) || 0,
                    balls: parseInt(it.balls, 10) || 0,
                    fours: parseInt(it.fours, 10) || 0,
                    sixes: parseInt(it.sixes, 10) || 0,
                    sr: parseFloat(it.strikeRate || it.sr) || 0,
                    active: it.active === true,
                    status: _looks_out(it) ? (it.outDescription || it.howOut || 'out') : 'not out',
                    _raw: it,
                });
            }
        }
    }
    return bats;
}
function _extract_bowlers_exact(inn) {
    const bowls = [];
    for (const [k, v] of walk(inn)) {
        if (typeof k === 'string' && k.toLowerCase() === "bowlers" && Array.isArray(v)) {
            for (const it of v) {
                if (typeof it !== 'object' || it === null) continue;
                const nm = it.bowlerName || it.name;
                if (!nm) continue;
                bowls.push({
                    name: nm,
                    overs: it.overs || 0,
                    runs: parseInt(it.runs, 10) || 0,
                    wickets: parseInt(it.wickets, 10) || 0,
                    economy: parseFloat(it.economy) || 0,
                    maidens: parseInt(it.maidens || it.maidensOvers, 10) || 0,
                    dots: parseInt(it.dots, 10) || 0,
                    wides: parseInt(it.wides, 10) || 0,
                    noballs: parseInt(it.noBalls || it.noballs, 10) || 0,
                    active: it.isactiveBowler || it.isActiveBowler || it.active,
                    other: it.isotherBowler || it.isOtherBowler,
                    _raw: it,
                });
            }
        }
    }
    return bowls;
}
function _pick_roles_and_stats(sr_json) {
    const score = _score_node(sr_json);
    const bbs = _find_bbs_merged(sr_json);
    const inn = _current_innings_node(score, bbs);
    const bats = _extract_batsmen_exact(inn);
    const bowls = _extract_bowlers_exact(inn);
    
    const activeBats = bats.filter(b => b.active);
    let striker = null;
    let nonStriker = null;
    if (activeBats.length >= 2) {
        striker = activeBats.find(b => b.on)?.name || activeBats[0].name;
        nonStriker = activeBats.find(b => b.name !== striker)?.name;
    } else {
        const aliveBats = bats.filter(b => !_looks_out(b._raw));
        striker = aliveBats.find(b => b.on)?.name;
        nonStriker = aliveBats.find(b => b.name !== striker)?.name;
        if (!striker && aliveBats.length > 0) {
            striker = aliveBats.sort((a, b) => (b.balls || 0) - (a.balls || 0))[0].name;
        }
    }
    const activeBowlers = bowls.filter(w => w.active);
    const mainBowler = activeBowlers.find(w => !w.other) || activeBowlers[0];
    const bowler = mainBowler?.name || (bowls.length > 0 ? bowls.sort((a,b) => _overs_to_float(b.overs) - _overs_to_float(a.overs))[0].name : null);
    
    const strikerStats = bats.find(b => b.name === striker) || {};
    const nonStrikerStats = bats.find(b => b.name === nonStriker) || {};
    const bowlerStats = bowls.find(w => w.name === bowler) || {};

    return {
        score,
        bbs,
        inn,
        bats,
        bowls,
        striker,
        nonStriker,
        bowler,
        strikerStats,
        nonStrikerStats,
        bowlerStats
    };
}
// =================== FETCH COM LÓGICA DE ANÁLISE COMPLETA ===================
async function fetchScorecard() {
    if (controller) controller.abort();
    controller = new AbortController();

    if (!ID) {
        document.getElementById('idJogo').innerHTML = `ID: <span>Não fornecido na URL</span>`;
        d3.selectAll('.placeholder-text').text("Erro: ID da partida não encontrado na URL.");
        return;
    }

    try {
        const response = await fetch(`https://lsc.fn.sportradar.com/common/en/Etc:UTC/cricket/get_scorecard/${ID}`, {signal: controller.signal});
        const sr_json = await response.json();
        
        const data = _pick_roles_and_stats(sr_json);
        const match = data.score;
        const innings = match.innings || [];

        // 1. EXTRAÇÃO E ATUALIZAÇÃO DO HEADER
        let status;
        switch(match.matchStatus){
            case 0: status = "Não iniciado"; break;
            case 1: case 2: status = "Em andamento"; break;
            case 3: status = "Finalizado"; break;
            default: status = "Indefinido";
        }
        document.getElementById('mainHeader').innerText = match.matchTitle || "Partida";
        document.getElementById('matchTitle').innerHTML = `Jogo: <span>${match.matchTitle || 'Partida'}</span>`;
        document.getElementById('status').innerHTML = `Status: <span>${status}</span>`;
        document.getElementById('idJogo').innerHTML = `ID: <span>${ID}</span>`;
        
        const t1Name = innings?.[0]?.teamName || "Time 1";
        const t2Name = innings?.[1]?.teamName || "Time 2";
        document.getElementById('teams').innerHTML = `Times: <span class="timeaz">${t1Name}</span> VS <span class="timever">${t2Name}</span>`;

        // 2. CONSOLIDAÇÃO DE DADOS PARA GRÁFICOS E TABELAS
        const overs_t1 = [];
        const overs_t2 = [];
        let cumRuns_t1 = 0;
        let cumRuns_t2 = 0;

        for (const o of data.bbs) {
            const overNum = parseFloat(o.overNumber);
            
            if (o.firstInnings) {
                const balls = o.firstInnings.split(',');
                const runs = balls.map(t => _parse_ball_token(t).runs).reduce((a,b) => a+b, 0);
                cumRuns_t1 += runs;
                overs_t1.push({ over: overNum, cum_runs: cumRuns_t1 });
            }
            if (o.secondInnings) {
                const balls = o.secondInnings.split(',');
                const runs = balls.map(t => _parse_ball_token(t).runs).reduce((a,b) => a+b, 0);
                cumRuns_t2 += runs;
                overs_t2.push({ over: overNum, cum_runs: cumRuns_t2 });
            }
        }
        
        // 3. RENDERIZAÇÃO DOS ELEMENTOS COM DADOS CONSOLIDADOS
        renderPlayerTables(data.bats, data.bowls);
        renderCurrentPlayers(data.strikerStats, data.nonStrikerStats, data.bowlerStats);

        drawTeamPerformance('#teamPerformance svg', (match.innings||[]).map(i=>({ team:i.teamName, runs: parseInt(i.runs,10)||0 })));
        
        const overPerformanceData = data.bbs.map(d => {
            const runs1 = d.firstInnings ? d.firstInnings.split(',').map(t => _parse_ball_token(t).runs).reduce((a,b) => a+b, 0) : 0;
            const runs2 = d.secondInnings ? d.secondInnings.split(',').map(t => _parse_ball_token(t).runs).reduce((a,b) => a+b, 0) : 0;
            return { over: +d.overNumber, team1: runs1, team2: runs2 };
        });

        let currentRuns1 = 0;
        let currentRuns2 = 0;
        const overPerformanceDataWithDiff = overPerformanceData.map(d => {
            currentRuns1 += d.team1;
            currentRuns2 += d.team2;
            const diff = currentRuns1 - currentRuns2;
            return { ...d, diff: diff };
        });

        drawOverPerformance('#overPerformance svg', overPerformanceDataWithDiff, match.innings?.map(i => ({ teamName: i.teamName })) || []);
        
        drawWorm('#worm svg', {t1:overs_t1, t2:overs_t2, teams: [t1Name, t2Name]});
        drawManhattan('#manhattan svg', overs_t1);
        
        const fow = (data.inn?.fallOfwickets || '').split(',').map(s=>s.trim()).filter(Boolean).map(s=>{
            const m = s.match(/(\S+)\s+(\d+)\/(\d+)\s*\((\d+)(?:\.(\d))?\)/);
            if(!m) return null;
            return { name:m[1], runs:+m[2], wkts:+m[3], over:+m[4]+(m[5]? +m[5]/6:0)};
        }).filter(Boolean);
        drawFOW('#fow svg', fow);

        const bat = data.bats.sort((a,b)=>b.runs-a.runs);
        drawBatsmen('#batsmen svg', bat);

        const bowl = data.bowls.sort((a,b)=>b.wickets-a.wickets);
        drawBowlers('#bowlers svg', bowl);

        const recent = (match.recentOvers||[]).map(o=>({ over:o.overNumber, runs:o.runs }));
        drawRecent('#recent svg', recent);

        // LÓGICA DE CÁLCULO DE TAXA DE CORRIDA
        const inningsData = match.innings || [];
        const firstInnings = inningsData[0];
        const secondInnings = inningsData[1];

        if (firstInnings && secondInnings) {
            const totalRunsTeam1 = parseInt(firstInnings.runs, 10) || 0;
            const oversTotal = parseFloat(firstInnings.oversLimit || 20); // Usa o limite de overs ou 20 por padrão
            const currentRunsTeam2 = parseInt(secondInnings.runs, 10) || 0;
            const currentOversTeam2 = parseFloat(secondInnings.overs) || 0;
            
            const requiredRuns = totalRunsTeam1 + 1 - currentRunsTeam2;
            const remainingOvers = oversTotal - currentOversTeam2;

            d3.select('#winChancePlaceholder').style('display', 'none');

            if (requiredRuns <= 0) {
                d3.select('#winChanceInfo').html(`
                    <h3>Time 2 venceu!</h3>
                    <p>O Time 2 alcançou o alvo.</p>
                `);
            } else if (remainingOvers <= 0) {
                d3.select('#winChanceInfo').html(`
                    <h3>Time 2 foi derrotado</h3>
                    <p>Fim do jogo. O Time 2 não alcançou o alvo.</p>
                `);
            } else if (currentOversTeam2 > 0) {
                const currentRunRate = currentRunsTeam2 / currentOversTeam2;
                const requiredRunRate = requiredRuns / remainingOvers;
                
                const crrColor = currentRunRate > requiredRunRate ? '#4ade80' : '#f87171';

                d3.select('#winChanceInfo').html(`
                    <p>Alvo do Time 2: <strong>${totalRunsTeam1 + 1}</strong></p>
                    <p>Overs Restantes: <strong>${remainingOvers.toFixed(1)}</strong></p>
                    <p>Taxa de Corrida Atual: <strong style="color: ${crrColor}">${currentRunRate.toFixed(2)}</strong></p>
                    <p>Taxa de Corrida Necessária: <strong>${requiredRunRate.toFixed(2)}</strong></p>
                `);
            } else {
                d3.select('#winChanceInfo').html(`
                    <h3>Calculando...</h3>
                    <p>Aguardando o Time 2 marcar a primeira corrida.</p>
                `);
            }
        } else {
            d3.select('#winChancePlaceholder').style('display', 'block').text("Dados incompletos para o cálculo.");
        }


        d3.selectAll('.placeholder-text').style('display', 'none');

        firstRender = false;
    } catch (error) {
        if (error.name !== "AbortError") console.error('Erro ao buscar scorecard:', error);
        d3.selectAll('.placeholder-text').text("Erro ao carregar os dados. Verifique o ID da partida.");
    }
}
// =================== TABELAS DE JOGADORES ===================
function renderPlayerTables(bats, bowls) {
    d3.select('#playersTablesPlaceholder').style('display', 'none');

    const notOutCount = bats.filter(b => b.status === 'not out').length;
    d3.select('#battersHeader').html(`Batters <span class="info-text">("${notOutCount} não eliminados")</span>`);

    const batterTable = d3.select(".batter-table tbody");
    batterTable.html("");
    
    const batterRows = batterTable.selectAll("tr")
        .data(bats)
        .enter()
        .append("tr");

    batterRows.append("td").text(d => d.name);
    batterRows.append("td").text(d => d.runs);
    batterRows.append("td").text(d => d.balls);
    batterRows.append("td").text(d => d.fours);
    batterRows.append("td").text(d => d.sixes);
    batterRows.append("td").text(d => d.sr ? d.sr.toFixed(2) : '-');
    batterRows.append("td").text(d => d.status);
    
    const bowlerTable = d3.select(".bowler-table tbody");
    bowlerTable.html("");
    
    const bowlerRows = bowlerTable.selectAll("tr")
        .data(bowls)
        .enter()
        .append("tr");
    
    bowlerRows.append("td").text(d => d.name);
    bowlerRows.append("td").text(d => d.overs);
    bowlerRows.append("td").text(d => d.runs);
    bowlerRows.append("td").text(d => d.wickets);
    bowlerRows.append("td").text(d => d.maidens || 0);
    bowlerRows.append("td").text(d => d.dots || 0);
    bowlerRows.append("td").text(d => d.wides || 0);
    bowlerRows.append("td").text(d => d.noballs || 0);
    bowlerRows.append("td").text(d => d.economy ? d.economy.toFixed(2) : '-');

    if (bats.length === 0 && bowls.length === 0) {
        d3.select('#playersTablesPlaceholder').style('display', 'block').text("Dados dos jogadores não disponíveis.");
    }
}

function renderCurrentPlayers(striker, nonStriker, bowler) {
    const container = d3.select('#currentPlayersInfo');
    container.html('');
    d3.select('#currentPlayersPlaceholder').style('display', 'none');

    if (Object.keys(striker).length > 0) {
        container.append('div').html(`
            <h3>Striker</h3>
            <p>${striker.name}: ${striker.runs || 0} runs (${striker.balls || 0} balls)</p>
            <p>SR: ${striker.sr ? striker.sr.toFixed(2) : '--'}</p>
        `);
    }
    if (Object.keys(nonStriker).length > 0) {
        container.append('div').html(`
            <h3>Non-Striker</h3>
            <p>${nonStriker.name}: ${nonStriker.runs || 0} runs (${nonStriker.balls || 0} balls)</p>
            <p>SR: ${nonStriker.sr ? nonStriker.sr.toFixed(2) : '--'}</p>
        `);
    }
    if (Object.keys(bowler).length > 0) {
        container.append('div').html(`
            <h3>Bowler</h3>
            <p>${bowler.name}: ${bowler.wickets || 0} wickets (${bowler.overs || 0} overs)</p>
            <p>Econ: ${bowler.economy ? bowler.economy.toFixed(2) : '--'}</p>
        `);
    }
    if (Object.keys(striker).length === 0 && Object.keys(nonStriker).length === 0 && Object.keys(bowler).length === 0) {
        d3.select('#currentPlayersPlaceholder').style('display', 'block').text("Informações de jogadores atuais não disponíveis.");
    }
}

// =================== TOOLTIP ===================
const tip = d3.select('#tip');
const showTip = (html, evt)=>{ tip.html(html).style('opacity',1).style('left',(evt.pageX+12)+'px').style('top',(evt.pageY-12)+'px'); };
const hideTip = ()=> tip.style('opacity',0);

// =================== GRÁFICOS COM ANIMAÇÕES ===================
function drawWorm(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.t1.length === 0 && data.t2.length === 0) { d3.select('#wormPlaceholder').style('display', 'block').text("Dados do Worm não disponíveis."); return; }
    const W=900,H=320,m={t:20,r:20,b:40,l:50};
    const allData = [...data.t1, ...data.t2];
    const maxRuns = d3.max(allData,d=>d.cum_runs)||0;
    const maxOvers = d3.max(allData,d=>d.over)||20;
    const x=d3.scaleLinear().domain([1, maxOvers]).range([m.l,W-m.r]);
    const y=d3.scaleLinear().domain([0,maxRuns*1.2]).range([H-m.b,m.t]);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    const line=d3.line().x(d=>x(d.over)).y(d=>y(d.cum_runs));
    
    const path1 = g.append('path').datum(data.t1).attr('fill','none').attr('stroke','#3b82f6').attr('stroke-width',2).attr('d',line);
    if(firstRender){ const totalLength = path1.node().getTotalLength(); path1.attr("stroke-dasharray", totalLength + " " + totalLength).attr("stroke-dashoffset", totalLength).transition().duration(1000).attr("stroke-dashoffset", 0); }

    const path2 = g.append('path').datum(data.t2).attr('fill','none').attr('stroke','#f97316').attr('stroke-width',2).attr('d',line);
    if(firstRender){ const totalLength = path2.node().getTotalLength(); path2.attr("stroke-dasharray", totalLength + " " + totalLength).attr("stroke-dashoffset", totalLength).transition().delay(500).duration(1000).attr("stroke-dashoffset", 0); }
    
    const legend = svg.append("g").attr("class", "legend").attr("transform", "translate(" + (W - 150) + "," + (m.t + 10) + ")");
    legend.append("rect").attr("x", 0).attr("y", 0).attr("width", 10).attr("height", 10).attr("fill", '#3b82f6');
    legend.append("text").attr("x", 15).attr("y", 9).text(data.teams[0]).style("font-size", "12px").attr("fill", "var(--text)");
    legend.append("rect").attr("x", 0).attr("y", 20).attr("width", 10).attr("height", 10).attr("fill", '#f97316');
    legend.append("text").attr("x", 15).attr("y", 29).text(data.teams[1]).style("font-size", "12px").attr("fill", "var(--text)");
}

function drawManhattan(sel, data) {
    const svg = d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#manhattanPlaceholder').style('display', 'block').text("Dados do Manhattan não disponíveis."); return; }
    const W=900, H=320, m={t:20,r:20,b:40,l:50};
    const x = d3.scaleBand().domain(data.map(d=>d.over)).range([m.l, W-m.r]).padding(0.2);
    const y = d3.scaleLinear().domain([0, d3.max(data, d => d.runs) || 0]).range([H-m.b, m.t]);
    const g=svg.append('g');
    g.append('g').attr('transform', `translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform', `translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('rect').data(data).join(enter => enter.append('rect').attr('x', d => x(d.over)).attr('y', y(0)).attr('width', x.bandwidth()).attr('height', 0).attr('fill', '#5cc8ff').call(enter => enter.transition().duration(800).attr('y', d => y(d.runs)).attr('height', d => y(0) - y(d.runs))), update => update.transition().duration(500).attr('y', d => y(d.runs)).attr('height', d => y(0) - y(d.runs)), exit => exit.remove()).on('mouseover', (event, d) => { showTip(`Over ${d.over}: ${d.runs} runs, ${d.wkts} Wickets`, event); }).on('mouseout', hideTip);
}

function drawFOW(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#fowPlaceholder').style('display', 'block').text("Dados de queda de wickets não disponíveis."); return; }
    const W=900,H=320,m={t:20,r:20,b:40,l:50};
    const x=d3.scaleLinear().domain([0,d3.max(data,d=>d.over)||20]).range([m.l,W-m.r]);
    const y=d3.scaleLinear().domain([0,d3.max(data,d=>d.runs)||0]).range([H-m.b,m.t]);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('circle').data(data).join(enter => enter.append('circle').attr('cx',d=>x(d.over)).attr('cy',y(0)).attr('r',0).attr('fill','#f87171').call(enter=>enter.transition().duration(800).attr('cy',d=>y(d.runs)).attr('r',5)), update => update.transition().duration(500).attr('cx',d=>x(d.over)).attr('cy',d=>y(d.runs)), exit => exit.remove());
}

function drawBatsmen(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#batsmenPlaceholder').style('display', 'block').text("Dados dos batsmen não disponíveis."); return; }
    const W=900,H=420,m={t:20,r:20,b:40,l:100};
    const x=d3.scaleLinear().domain([0,d3.max(data,d=>d.runs)||0]).range([m.l,W-m.r]);
    const y=d3.scaleBand().domain(data.map(d=>d.name)).range([m.t,H-m.b]).padding(0.1);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('rect').data(data).join(enter => enter.append('rect').attr('x',x(0)).attr('y',d=>y(d.name)).attr('height',y.bandwidth()).attr('width',0).attr('fill','var(--accent)').call(enter=>enter.transition().duration(800).attr('width',d=>x(d.runs)-x(0))), update => update.transition().duration(500).attr('width',d=>x(d.runs)-x(0)), exit => exit.remove());
}

function drawBowlers(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#bowlersPlaceholder').style('display', 'block').text("Dados dos bowlers não disponíveis."); return; }
    const W=900,H=420,m={t:20,r:20,b:40,l:120};
    const x=d3.scaleLinear().domain([0,d3.max(data,d=>d.wickets)||0]).range([m.l,W-m.r]);
    const y=d3.scaleBand().domain(data.map(d=>d.name)).range([m.t,H-m.b]).padding(0.1);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('rect').data(data).join(enter => enter.append('rect').attr('x',x(0)).attr('y',d=>y(d.name)).attr('height',y.bandwidth()).attr('width',0).attr('fill','#f87171').call(enter=>enter.transition().duration(800).attr('width',d=>x(d.wickets)-x(0))), update => update.transition().duration(500).attr('width',d=>x(d.wickets)-x(0)), exit => exit.remove());
}

function drawRecent(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#recentPlaceholder').style('display', 'block').text("Dados de overs recentes não disponíveis."); return; }
    const W=900,H=240,m={t:20,r:20,b:40,l:50};
    const x=d3.scaleBand().domain(data.map(d=>d.over)).range([m.l,W-m.r]).padding(0.1);
    const y=d3.scaleLinear().domain([0,d3.max(data,d=>d.runs)||0]).range([H-m.b,m.t]);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('rect').data(data).join(enter => enter.append('rect').attr('x',d=>x(d.over)).attr('width',x.bandwidth()).attr('y',y(0)).attr('height',0).attr('fill','var(--accent)').call(enter=>enter.transition().duration(800).attr('y',d=>y(d.runs)).attr('height',d=>y(0)-y(d.runs))), update => update.transition().duration(500).attr('y',d=>y(d.runs)).attr('height',d=>y(0)-y(d.runs)), exit => exit.remove());
}

function drawTeamPerformance(sel,data){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#teamPerformancePlaceholder').style('display', 'block').text("Dados de desempenho de times não disponíveis."); return; }
    const W=900,H=320,m={t:20,r:20,b:40,l:100};
    const x=d3.scaleLinear().domain([0,d3.max(data,d=>d.runs)||0]).range([m.l,W-m.r]);
    const y=d3.scaleBand().domain(data.map(d=>d.team)).range([m.t,H-m.b]).padding(0.3);
    const colors=["#3b82f6","#f97316"];
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    g.selectAll('rect').data(data).join(enter => enter.append('rect').attr('x',x(0)).attr('y',(d,i)=>y(d.team)).attr('height',y.bandwidth()).attr('width',0).attr('fill',(d,i)=>colors[i%colors.length]).call(enter=>enter.transition().duration(800).attr('width',d=>x(d.runs)-x(0))), update => update.transition().duration(500).attr('width',d=>x(d.runs)-x(0)), exit => exit.remove());
}

function drawOverPerformance(sel,data,teams){
    const svg=d3.select(sel); svg.selectAll('*').remove();
    if(data.length === 0) { d3.select('#overPerformancePlaceholder').style('display', 'block').text("Dados de pontos por over não disponíveis."); return; }
    const W=900,H=320,m={t:20,r:20,b:40,l:50};
    const maxRuns = d3.max(data,d=>Math.max(d.team1,d.team2)) || 0;
    const y=d3.scaleLinear().domain([0,maxRuns*1.1]).range([H-m.b,m.t]);
    const x=d3.scaleBand().domain(data.map(d=>d.over)).range([m.l,W-m.r]).padding(0.2);
    const g=svg.append('g');
    g.append('g').attr('transform',`translate(0,${H-m.b})`).call(d3.axisBottom(x));
    g.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(y));
    const barWidth=x.bandwidth()/2;
    g.selectAll('.bar1').data(data).join(enter=>enter.append('rect').attr('class','bar1').attr('x',d=>x(d.over)).attr('y',y(0)).attr('width',barWidth).attr('height',0).attr('fill','#3b82f6').call(enter=>enter.transition().duration(800).attr('y',d=>y(d.team1)).attr('height',d=>y(0)-y(d.team1))),update=>update.transition().duration(500).attr('y',d=>y(d.team1)).attr('height',d=>y(0)-y(d.team1)),exit=>exit.remove());
    g.selectAll('.bar2').data(data).join(enter=>enter.append('rect').attr('class','bar2').attr('x',d=>x(d.over)+barWidth).attr('y',y(0)).attr('width',barWidth).attr('height',0).attr('fill','#f97316').call(enter=>enter.transition().duration(800).attr('y',d=>y(d.team2)).attr('height',d=>y(0)-y(d.team2))),update=>update.transition().duration(500).attr('y',d=>y(d.team2)).attr('height',d=>y(0)-y(d.team2)),exit=>exit.remove());
    
    g.selectAll('.diff-text').data(data).join(enter=>enter.append('text').attr('class','diff-text').attr('x',d=>x(d.over)+barWidth*1.5).attr('y',d=>y(d.team2)-5).text(d=>d.diff<0?'-':`+${d.diff}`).attr('text-anchor','middle').attr('fill',d=>d.diff<0?'#f87171':'#4ade80').style('font-size','10px'),update=>update.transition().duration(500).attr('y',d=>y(d.team2)-5).text(d=>d.diff<0?'-':`+${d.diff}`).attr('fill',d=>d.diff<0?'#f87171':'#4ade80'),exit=>exit.remove());

    if(teams.length >= 2){ svg.append('circle').attr('cx',W-150).attr('cy',30).attr('r',6).attr('fill','#3b82f6'); svg.append('text').attr('x',W-140).attr('y',34).text(teams[0].teamName).attr('fill','var(--text)').style('font-size','12px'); svg.append('circle').attr('cx',W-150).attr('cy',50).attr('r',6).attr('fill','#f97316'); svg.append('text').attr('x',W-140).attr('y',54).text(teams[1].teamName).attr('fill','var(--text)').style('font-size','12px'); }
}

document.addEventListener('DOMContentLoaded', fetchScorecard);
</script>

</html>